import pytest

from . import mock_redshift
from library.aws.redshift import RedshiftClusterChecker
from library.aws.utility import Account

region = "us-east-1"

clusters = {
    "cluster1": {
        "Description": "Cluster has public access",
        "DBName": "test1",
        "ClusterType": "single-node",
        "NodeType": "ds2.xlarge",
        "MasterUsername": "user1",
        "MasterUserPassword": "testUser1password123",
        "PubliclyAccessible": True,
        "Encrypted": True,
        "CheckShouldPass": False
    },
    "cluster2": {
        "Description": "Cluster has private access",
        "DBName": "test2",
        "ClusterType": "single-node",
        "NodeType": "ds2.xlarge",
        "MasterUsername": "user2",
        "MasterUserPassword": "testUser2password123",
        "PubliclyAccessible": False,
        "Encrypted": True,
        "CheckShouldPass": True
    }
}


def find_rule_prop(cluster_details, prop, default):

    try:
        return clusters[cluster_details.name][prop]
    except KeyError:
        return default


def ident_cluster_test(arg):
    """
    Used to build identification string for each autogenerated test (for easy recognition of failed tests).

    :param cluster_details: dict with information about rules from
                        RedshiftClusterChecker(...)
    :return: identification string with cluster name.
    """
    if isinstance(arg, bool):
        return "remediated" if arg else "original"
    else:
        descr = find_rule_prop(arg, "Description", "default description")
        return f"params: {arg.name} ({descr})"


def pytest_generate_tests(metafunc):
    """
    Entrypoint for tests (built-in pytest function for dynamic generation of test cases).
    """
    # Launch Redshift mocking and env preparation
    mock_redshift.start()
    test_clusters = mock_redshift.create_env_clusters(clusters, region)

    account = Account(region=region)

    # validate ebs volumes in mocked env
    checker = RedshiftClusterChecker(account)
    checker.check(clusters=test_clusters)

    for cluster in checker.clusters:
        if cluster.is_public:
            cluster.modify_cluster(False)

    checker_remediated = RedshiftClusterChecker(account)
    checker_remediated.check()

    redshift_clusters = [(cluster, False) for cluster in checker.clusters]
    redshift_clusters += [(cluster, True) for cluster in checker_remediated.clusters]

    # create test cases for each response
    metafunc.parametrize("cluster, remediated", redshift_clusters, ids=ident_cluster_test)


@pytest.mark.redshift_public_access
def test_cluster(cluster, remediated):
    """
    Actual testing function.

    :param cluster_details: dict with information about rules from
                        RedshiftClusterChecker(...)
    :param remediated: remediation details.
    :return: nothing, raises AssertionError if actual test result is not matched with expected
    """
    expected = True if remediated else find_rule_prop(cluster, "CheckShouldPass", True)
    assert expected == (not cluster.is_public)
